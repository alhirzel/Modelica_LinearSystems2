<HTML>
<HEAD>
<TITLE>Modelica_LinearSystems2.Math.Matrices</TITLE>
<META name="HTML-Generator" content="Dymola">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<META name="description" content="&quot;Package of functions operating on matrices&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal}
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Matrices<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices"></A><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math"
>Modelica_LinearSystems2.Math</A>.Matrices</H2>
<B>Package of functions operating on matrices</B>
<P>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This package provides functions operating on matrices, see also
Matrices</a>.
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Package (Icon for standard packages).
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.MatricesS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>LAPACK</A>
</TD><TD>Package of LAPACK functions</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M15d3e929aebf276bmplesS.png" ALT="Modelica_LinearSystems2.Math.Matrices.Examples" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_Examples.html#Modelica_LinearSystems2.Math.Matrices.Examples"
>Examples</A>
</TD><TD>Package of examples to demonstrate the usage of matrices</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Md441540169b8ec80.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.care" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.care"
>care</A>
</TD><TD>Solution of continuous-time algebraic Riccati equations</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Md441540169b8ec80.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.cholesky" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.cholesky"
>cholesky</A>
</TD><TD>Compute the Cholesky factorization of a symmetric positive definte matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Md441540169b8ec80.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.choleskyDownDate" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.choleskyDownDate"
>choleskyDownDate</A>
</TD><TD>Compute the cholesky factor Ld according to Ad=Ld&#39;*Ld=A - v*v&#39; with A=L&#39;*L</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Md441540169b8ec80.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.choleskyDownDate2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.choleskyDownDate2"
>choleskyDownDate2</A>
</TD><TD>Compute the cholesky factor Ld according to Ad=Ld&#39;*Ld=A - v*v&#39; with A=L&#39;*L</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Md441540169b8ec80.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.choleskyUpDate" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.choleskyUpDate"
>choleskyUpDate</A>
</TD><TD>Compute the cholesky factor Lu according to Au=Lu&#39;*Lu=A + v*v&#39; with A=L&#39;*L</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M4c512ba09a790cdaumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.conditionNumber" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.conditionNumber"
>conditionNumber</A>
</TD><TD>Calculate the condition number norm(A)*norm(inv(A))</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Md463a19c69bb6c80.dareS.png" ALT="Modelica_LinearSystems2.Math.Matrices.dare" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.dare"
>dare</A>
</TD><TD>Solution of discrete-time algebraic Riccati equations</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M8e52d84b2b4dbbe1s.detS.png" ALT="Modelica_LinearSystems2.Math.Matrices.det" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.det"
>det</A>
</TD><TD>Determinant of a matrix (computed by LU decomposition)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Mc384e518cfe86b25punovS.png" ALT="Modelica_LinearSystems2.Math.Matrices.dlyapunov" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.dlyapunov"
>dlyapunov</A>
</TD><TD>Solution of continuous-time Lyapunov equation A&#39;X*A - X = C</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Mc384e518cfe86b25punovS.png" ALT="Modelica_LinearSystems2.Math.Matrices.dsylvester" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.dsylvester"
>dsylvester</A>
</TD><TD>Solution of discrete-time Sylvester equation A*X*B + sgn*X = C</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Mea4e8dbe6499a9cbaluesS.png" ALT="Modelica_LinearSystems2.Math.Matrices.eigenValues" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.eigenValues"
>eigenValues</A>
</TD><TD>Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Mea4e8dbe6499a9cbaluesS.png" ALT="Modelica_LinearSystems2.Math.Matrices.equalityLeastSquares" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.equalityLeastSquares"
>equalityLeastSquares</A>
</TD><TD>Solve a linear equality constrained least squares problem</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M41ba4d83896fd854liplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.fliplr" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.fliplr"
>fliplr</A>
</TD><TD>Flip the columns of a matrix in left/right direction</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M41ba4d83896fd854liplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.flipud" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.flipud"
>flipud</A>
</TD><TD>Flip the columns of a matrix in up/down direction</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M41ba4d83896fd854liplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.fromFile" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.fromFile"
>fromFile</A>
</TD><TD>Read matrix from a matlab file</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M41ba4d83896fd854liplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.generalizedEigenvaluesTriangular" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.generalizedEigenvaluesTriangular"
>generalizedEigenvaluesTriangular</A>
</TD><TD>Compute invariant zeros of linear state space system with a generalized system matrix [A, B, C, D] which is of upper Hessenberg form</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M41ba4d83896fd854liplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.hessenberg" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.hessenberg"
>hessenberg</A>
</TD><TD>Transform a matrix to upper Hessenberg form</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M41ba4d83896fd854liplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.householderReflexion" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.householderReflexion"
>householderReflexion</A>
</TD><TD>Reflect each of the vectors ai of matrix  A=[a1, a2, ..., an] on a plane with orthogonal vector u</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M41ba4d83896fd854liplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.householderSimilarityTransformation" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.householderSimilarityTransformation"
>householderSimilarityTransformation</A>
</TD><TD>Calculate the similarity transformation S*A*S of matrix A with symmetric householder matrix S = I - 2u*u&#39;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M37a92c25c3f621edares2S.png" ALT="Modelica_LinearSystems2.Math.Matrices.leastSquares2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.leastSquares2"
>leastSquares2</A>
</TD><TD>Solve overdetermined or underdetermined real system of linear equations A*X=B in a least squares sense (A may be rank deficient)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M37a92c25c3f621edares2S.png" ALT="Modelica_LinearSystems2.Math.Matrices.leastSquares" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.leastSquares"
>leastSquares</A>
</TD><TD>Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M305bf8dcef6daf66punovS.png" ALT="Modelica_LinearSystems2.Math.Matrices.lyapunov" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.lyapunov"
>lyapunov</A>
</TD><TD>Solution of continuous-time Lyapunov equation X*A + A&#39;*X = C</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M305bf8dcef6daf66punovS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LQ" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LQ"
>LQ</A>
</TD><TD>LQ decomposition of a rectangular matrix without column pivoting (A = L*Q)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LUS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LU"
>LU</A>
</TD><TD>LU decomposition of square or rectangular matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LUS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU_solve" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LU_solve"
>LU_solve</A>
</TD><TD>Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Mf22b39316a14a3e0olve2S.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU_solve2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LU_solve2"
>LU_solve2</A>
</TD><TD>Solve real system of linear equations P*L*U*X=B with a B vector and an LU decomposition (from LU(..))</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Mf22b39316a14a3e0olve2S.png" ALT="Modelica_LinearSystems2.Math.Matrices.toUpperHessenberg" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.toUpperHessenberg"
>toUpperHessenberg</A>
</TD><TD>Transform a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Md5be543069be5488.normS.png" ALT="Modelica_LinearSystems2.Math.Matrices.norm" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.norm"
>norm</A>
</TD><TD>Returns the norm of a matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Md5be543069be5488.normS.png" ALT="Modelica_LinearSystems2.Math.Matrices.nullspace" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.nullspace"
>nullspace</A>
</TD><TD>Orthonormal nullspace of a matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M6bb4d50046538ba1onalQS.png" ALT="Modelica_LinearSystems2.Math.Matrices.orthogonalQ" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.orthogonalQ"
>orthogonalQ</A>
</TD><TD>Generates a real orthogonal matrix Q defined as the product of IHI-ILO elementary reflectors</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M6bb4d50046538ba1onalQS.png" ALT="Modelica_LinearSystems2.Math.Matrices.printMatrix" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.printMatrix"
>printMatrix</A>
</TD><TD>Print matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M6bb4d50046538ba1onalQS.png" ALT="Modelica_LinearSystems2.Math.Matrices.printMatrixInHtml" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.printMatrixInHtml"
>printMatrixInHtml</A>
</TD><TD>Print a matrix in html format on file (without html/body heading)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M6bb4d50046538ba1onalQS.png" ALT="Modelica_LinearSystems2.Math.Matrices.QR" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.QR"
>QR</A>
</TD><TD>QR decomposition of a rectangular matrix without column pivoting (A = Q*R). Return the full square Q-matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Ma4ff825c368ce509rcondS.png" ALT="Modelica_LinearSystems2.Math.Matrices.rcond" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rcond"
>rcond</A>
</TD><TD>Reciprocal condition number</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M8e5689e52b4de133s.rsfS.png" ALT="Modelica_LinearSystems2.Math.Matrices.rsf" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rsf"
>rsf</A>
</TD><TD>Computes the real Schur form (RSF) of a square matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.M8e5689e52b4de133s.rsfS.png" ALT="Modelica_LinearSystems2.Math.Matrices.rsf2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rsf2"
>rsf2</A>
</TD><TD>Computes the real Schur form (RSF) of a square matrix but uses lapack.dgees</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Mb82816ef369aea08solveS.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.solve"
>solve</A>
</TD><TD>Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Mb82816ef369aea08solveS.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.solve2"
>solve2</A>
</TD><TD>Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Mb82816ef369aea08solveS.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve2r" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.solve2r"
>solve2r</A>
</TD><TD>Solve real system of linear equations X*op(A)=B with a B matrix (Gaussian elemination with partial pivoting)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Mff211ce3a0bb15ccesterS.png" ALT="Modelica_LinearSystems2.Math.Matrices.sylvester" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.sylvester"
>sylvester</A>
</TD><TD>Solution of continuous-time Sylvester equation A*X + X*B = C</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Mca19caf536e45ca8traceS.png" ALT="Modelica_LinearSystems2.Math.Matrices.trace" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.trace"
>trace</A>
</TD><TD>Sum of the diagonal elements of A</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Mce8a6d083e700bd7angleS.png" ALT="Modelica_LinearSystems2.Math.Matrices.triangle" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.triangle"
>triangle</A>
</TD><TD>Return the upper/lower triangular part of a square matrix</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE care<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.care"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.care</H2>
<B>Solution of continuous-time algebraic Riccati equations</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
Function <b>care</b> computes the solution <b>X</b> of the continuous-time
algebraic Riccati equation
</p>
<blockquote><pre>
<b>Q</b> + <b>A</b>'*<b>X</b> + <b>X</b>*<b>A</b> - <b>X</b>*<b>G</b>*<b>X</b> = <b>0</b>
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>
<b>G</b> = <b>B</b>*<b>R</b><sup>-1</sup>*<b>B</b>'
</pre></blockquote>
<p>
using the Schur vector approach proposed by Laub [1].
</p>
<p>
It is assumed that <b>Q</b> is symmetric and positve semidefinite and <b>R</b> is
symmetric, nonsingular and positive definite, (<b>A</b>,<b>B</b>) is stabilizable
and (<b>A</b>,<b>Q</b>) is detectable.
<b>
The assumptions are not checked in this function!
</b>
</p>
<p>
The assumptions guarantee that Hamiltonian matrix
</p>
<blockquote><pre>
<b>H</b> = [<b>A</b>, -<b>G</b>; -<b>Q</b>, -<b>A</b>']
</pre></blockquote>
<p>
has no pure imaginary eigenvalue and can be put to an ordered real Schur form
</p>
<blockquote><pre>
<b>U</b>'*<b>H</b>*<b>U</b> = <b>S</b> = [<b>S</b>11, <b>S</b>12; <b>0</b>, <b>S</b>22]
</pre></blockquote>
<p>
with orthogonal similarity transformation <b>U</b>. <b>S</b> is ordered in such a way,
that <b>S11</b> contains the n stable eigenvalues of the closed loop system with system matrix
</p>
<blockquote><pre>
<b>A</b> - <b>B</b>*<b>R</b><sup>-1</sup>*<b>B</b>'*<b>X</b>
</pre></blockquote>
<p>
If <b>U</b> is partitioned to
</p>
<blockquote><pre>
<b>U</b> = [<b>U</b>11, <b>U</b>12; <b>U</b>21, <b>U</b>22]
</pre></blockquote>
<p>
with dimenstions according to <b>S</b>, the solution <b>X</b> can be calculated by
</p>
<blockquote><pre>
<b>X</b>*<b>U</b>11 = <b>U</b>21.
</pre></blockquote>
<p>
The algorithm uses LAPACK routines dgehrd (to compute the upper Hessenberg matrix of <b>H</b>), dorghr (to calculate the orthogonal
matrix from the elementary reflectors as returned from dgehrd), dhseqr (to put transformed <b>H</b> to Schur form and to calculate the eigenvalues
of the closed loop system) and dtrsen (to compute the ordered real Schur form and matrix <b>U</b>).
</p>

<h4><a name="References">References</a></h4>
<dl>
<dt>&nbsp;[1] Laub A.J. (1979):</dt>
<dd> <b>A Schur Method for Solving Algebraic Riccati equations</b>.
     IEEE Trans. Auto. Contr., AC-24, pp. 913-921.<br>&nbsp;</dd>
</dl>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>R[size(B, 2), size(B, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Q[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>refine</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 1), size(A, 2)]</TD><TD>Stabilizing solution of CARE</TD></TR>
<TR><TD>ev[size(A, 1)]</TD><TD>Eigenvalues of the closed loop system</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE cholesky<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.cholesky"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.cholesky</H2>
<B>Compute the Cholesky factorization of a symmetric positive definte matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>upper</TD><TD>True if the upper triangle of A is provided</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>H[size(A, 1), size(A, 2)]</TD><TD>Cholesky factor U or L for A = U&#39;*U or A = L*L&#39;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE choleskyDownDate<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.choleskyDownDate"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.choleskyDownDate</H2>
<B>Compute the cholesky factor Ld according to Ad=Ld&#39;*Ld=A - v*v&#39; with A=L&#39;*L</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Ldd = Matrices.<b>choleskyDownDate</b>(L, v);
Ldd = Matrices.<b>choleskyDownDate</b>(L, v, true);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the rank-1-downdated
Cholesky factorization <b>Ldd</b>, with
</p>
<blockquote>
  <b>Add</b> = <b>Ldd</b>*<b>Ldd</b><sup>T</sup> =
  <b>A</b> -  <b>v</b>*<b>v</b><sup>T</sup> =
  <b>L</b>*<b>L</b><sup>T</sup> -  <b>v</b>*<b>v</b><sup>T</sup>
</blockquote>
<p>
from the input <b>L</b>, i.e. the left (lower) Cholesky factor of the
original matrix <b>A</b>. The algortihm is taken from [1].
</p>
<p>
Matrix <b>Ldd</b> is calculated by
</p>
<blockquote>
  [<b>v</b>, <b>Ldd</b>]<sup>T</sup> = <b>H</b> *[<b>0</b>, <b>L</b>]<sup>T</sup>
</blockquote>
<p>
with orthogonal Matrix <b>H</b> such that
</p>
<blockquote>
  <b>v</b>*<b>v</b><sup>T</sup> + <b>Ldd</b>*<b>Ldd</b><sup>T</sup> =
  [<b>v</b>, <b>Ldd</b>] * [<b>v</b>, <b>Ldd</b>]<sup>T</sup> =
  [<b>0</b>, <b>L</b>]*<b>H</b><sup>T</sup> *<b>H</b>*[<b>0</b>, <b>L</b>]<sup>T</sup> =
  [<b>0</b>, <b>L</b>]*[<b>0</b>, <b>L</b>]<sup>T</sup> = <b>L</b>*<b>L</b><sup>T</sup> = <b>A</b>,
</blockquote>
<p>
i.e., by orthogonal transformation
</p>
<blockquote>
  <b>H</b> = <b>H</b>_1*...*<b>H</b>_n.
</blockquote>
<p>
The matrices <b>H</b>_i are Givens matrices computed such that
</p>
<blockquote>
  <b>H</b>_1*<b>H</b>_2*...*<b>H</b>_n*[z, <b>a</b><sup>T</sup>]<sup>T</sup> = [1, 0, ..., 0]<sup>T</sup>,
</blockquote>
<p>
with <b>a</b> is the solution of
</p>
<blockquote>
  <b>L</b>*<b>a</b> = <b>v</b>
</blockquote>
<p>
and
</p>
<blockquote>
  z = ||<b>a</b>||.
</blockquote>
<p>
The following sequence illustrate the principle of calculating the <b>H</b>_i, starting with <b>H</b>_n
</p>
<blockquote><pre>
|z|       |z|       |z|       |z|
|a|  H_3  |a|  H_2  |a|  H_1  |0|
|a| ----> |a| --->  |0| --->  |0|
|a|       |0|       |0|       |0|
</pre></blockquote>
<p>
Note, that the z and a are different in each column.
It is shown in [1] that this algorithm results in the modified Cholesky factor <b>Ldd</b>.
</p>
<p>
With the boolean input "upper" the user specifies whether the matrix <b>L</b> is lower
or upper triangular matrix (left or right Cholesky factor).
If "upper==true", the output <b>Ldd</b> is also upper triangular. Default is "upper==false".
</p>

<h4><a name="References">References</a></h4>
<dl>
<dt>&nbsp;[1] Dongarra J. J., Bunch J. R., Moler G. B., Stewart G.W. (1987):</dt>
<dd> <b>LINPACK Users' Guide</b>.
     Society for Industrial Mathematics.<br>&nbsp;</dd>
</dl>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>L[:, size(L, 1)]</TD><TD>Cholesky factor</TD></TR>
<TR><TD>v[size(L, 1)]</TD><TD>Real vector A+v*v&#39;</TD></TR>
<TR><TD>upper</TD><TD>True if the upper triangle of A is provided</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Ldd[size(L, 1), size(L, 2)]</TD><TD>Updated Cholesky factor</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE choleskyDownDate2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.choleskyDownDate2"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.choleskyDownDate2</H2>
<B>Compute the cholesky factor Ld according to Ad=Ld&#39;*Ld=A - v*v&#39; with A=L&#39;*L</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Ldd = Matrices.<b>choleskyDownDate</b>(L, v);
Ldd = Matrices.<b>choleskyDownDate</b>(L, v, true);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the rank-1-downdated
Cholesky factorization <b>Ldd</b>, with
</p>
<blockquote>
  <b>Add</b> = <b>Ldd</b>*<b>Ldd</b><sup>T</sup> =
  <b>A</b> -  <b>v</b>*<b>v</b><sup>T</sup> =
  <b>L</b>*<b>L</b><sup>T</sup> -  <b>v</b>*<b>v</b><sup>T</sup>
</blockquote>
<p>
from the input <b>L</b>, i.e. the left (lower) Cholesky factor of the
original matrix <b>A</b>. The algortihm is taken from [1].
</p>
<p>
Matrix <b>Ldd</b> is calculated by
</p>
<blockquote>
  [<b>v</b>, <b>Ldd</b>]<sup>T</sup> = <b>H</b> *[<b>0</b>, <b>L</b>]<sup>T</sup>
</blockquote>
<p>
with orthogonal Matrix <b>H</b> such that
</p>
<blockquote>
  <b>v</b>*<b>v</b><sup>T</sup> + <b>Ldd</b>*<b>Ldd</b><sup>T</sup> =
  [<b>v</b>, <b>Ldd</b>] * [<b>v</b>, <b>Ldd</b>]<sup>T</sup> =
  [<b>0</b>, <b>L</b>]*<b>H</b><sup>T</sup> *<b>H</b>*[<b>0</b>, <b>L</b>]<sup>T</sup> =
  [<b>0</b>, <b>L</b>]*[<b>0</b>, <b>L</b>]<sup>T</sup> = <b>L</b>*<b>L</b><sup>T</sup> = <b>A</b>,
</blockquote>
<p>
i.e., by orthogonal transformation
</p>
<blockquote>
  <b>H</b> = <b>H</b>_1*...*<b>H</b>_n.
</blockquote>
<p>
The matrices <b>H</b>_i are Givens matrices computed such that
</p>
<blockquote>
  <b>H</b>_1*<b>H</b>_2*...*<b>H</b>_n*[z, <b>a</b><sup>T</sup>]<sup>T</sup> = [1, 0, ..., 0]<sup>T</sup>,
</blockquote>
<p>
with <b>a</b> is the solution of
</p>
<blockquote>
  <b>L</b>*<b>a</b> = <b>v</b>
</blockquote>
<p>
and
</p>
<blockquote>
  z = ||<b>a</b>||.
</blockquote>
<p>
The following sequence illustrate the principle of calculating the <b>H</b>_i, starting with <b>H</b>_n
</p>
<blockquote><pre>
|z|       |z|       |z|       |z|
|a|  H_3  |a|  H_2  |a|  H_1  |0|
|a| ----> |a| --->  |0| --->  |0|
|a|       |0|       |0|       |0|
</pre></blockquote>
<p>
Note, that the z and a are different in each column.
It is shown in [1] that this algorithm results in the modified Cholesky factor <b>Ldd</b>.
</p>
<p>
With the boolean input "upper" the user specifies whether the matrix <b>L</b> is lower
or upper triangular matrix (left or right Cholesky factor).
If "upper==true", the output <b>Ldd</b> is also upper triangular. Default is "upper==false".
</p>

<h4><a name="References">References</a></h4>
<dl>
<dt>&nbsp;[1] Dongarra J. J., Bunch J. R., Moler G. B., Stewart G.W. (1987):</dt>
<dd> <b>LINPACK Users' Guide</b>.
     Society for Industrial Mathematics.<br>&nbsp;</dd>
</dl>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>L[:, size(L, 1)]</TD><TD>Cholesky factor</TD></TR>
<TR><TD>v[size(L, 1)]</TD><TD>Real vector A+v*v&#39;</TD></TR>
<TR><TD>upper</TD><TD>True if the upper triangle of A is provided</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Ldd[size(L, 1), size(L, 2)]</TD><TD>Updated Cholesky factor</TD></TR>
<TR><TD>infoOut</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE choleskyUpDate<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.choleskyUpDate"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.choleskyUpDate</H2>
<B>Compute the cholesky factor Lu according to Au=Lu&#39;*Lu=A + v*v&#39; with A=L&#39;*L</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Lud = Matrices.<b>choleskyUpDate</b>(L, v);
Lud = Matrices.<b>choleskyUpDate</b>(L, v, true);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the rank-1-updated Cholesky factorization <b>Lud</b>, with
</p>
<blockquote>
  <b>Aud</b> = <b>Lud</b>*<b>Lud</b><sup>T</sup> =
  <b>A</b> +  <b>v</b>*<b>v</b><sup>T</sup> =
  <b>L</b>*<b>L</b><sup>T</sup> +  <b>v</b>*<b>v</b><sup>T</sup>
</blockquote>
<p>
from the input <b>L</b>, i.e. the left (lower) Cholesky factor of the original matrix <b>A</b>.<br>
The approach is a transformation <b>H</b>*[<b>v</b>, <b>L</b>]' = [<b>0</b>, <b>Lud</b>]' with orthonormal matrix <b>H</b> such, that
</p>
<blockquote>
  [<b>0</b>, <b>Lud</b>] * [<b>0</b>, <b>Lud</b>]<sup>T</sup> =
  [<b>v</b>, <b>L</b>]*<b>H</b><sup>T</sup> *<b>H</b>*[<b>v</b>, <b>L</b>]<sup>T</sup> =
  [<b>v</b>, <b>L</b>]*[<b>v</b>, <b>L</b>]<sup>T</sup> = <b>v</b>*<b>v</b><sup>T</sup> + <b>A</b>
</blockquote>
<p>
and matrix <b>Lud</b> is lower (upper) triangular. The transformation is performed
by n (order of <b>A</b>) Givens rotations.
The following sequence illustrates the principle of stepwise transformation of
matrix [v, L]'. Symbol "*" represents arbitrary elements. For each step the changed
elements are bold.
</p>
<blockquote><pre>
| v' |    | * * * * |       | 0 <b>*</b> <b>*</b> <b>*</b> |       | 0 0 <b>*</b> <b>*</b> |       | 0 0 0 <b>*</b> |       | 0 0 0 0 |
|    |    | * * * * |       | <b>*</b> <b>*</b> <b>*</b> <b>*</b> |       | * * * * |       | * * * * |       | * * * * |
| L' | =  | 0 * * * |  ->   | 0 * * * |  ->   | 0 <b>*</b> <b>*</b> <b>*</b> |  ->   | 0 * * * |  ->   | 0 * * * |
|    |    | 0 0 * * |       | 0 0 * * |       | 0 0 * * |       | 0 0 <b>*</b> <b>*</b> |       | 0 0 * * |
|    |    | 0 0 0 * |       | 0 0 0 * |       | 0 0 0 * |       | 0 0 0 * |       | 0 0 0 <b>*</b> |

</pre></blockquote>
<p>
With the boolean input "upper" the user specifies wether the matrix <b>L</b>
is lower or upper triangular matrix (left or right Cholesky factor).
If "upper==true", the output <b>Lud</b> is also upper triangular. Default is "upper==false".
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>L[:, size(L, 1)]</TD><TD>Cholesky factor</TD></TR>
<TR><TD>v[size(L, 1)]</TD><TD>Real vector A+v*v&#39;</TD></TR>
<TR><TD>upper</TD><TD>True if the upper triangle of A is provided and the modified upper triangle will be returned</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Lud[size(L, 1), size(L, 2)]</TD><TD>Updated Cholesky factor</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE conditionNumber<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.M4c512ba09a790cdaumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.conditionNumber" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.conditionNumber"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.conditionNumber</H2>
<B>Calculate the condition number norm(A)*norm(inv(A))</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
r = Matrices.<b>conditionNumber</b>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates the the condition number
(norm(<b>A</b>) * norm(inv(<b>A</b>))) of a general real matrix <b>A</b>,
in either the 1-norm, 2-norm or the infinity-norm. In the case of 2-norm
the result is the ratio of the largest to the smallest singular value to <b>A</b>.
</p>

<h4>Example</h4>
<blockquote><pre>
  A = [1, 2
       2, 1];
  r = conditionNumber(A);

results in:

  r = 3.0
</pre></blockquote>

<h4>See also</h4>
<p>
<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rcond"
>Matrices.rcond</a>
</p>
<pre>&lt;/html&gt;</PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Input matrix</TD></TR>
<TR><TD>p</TD><TD>Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>result</TD><TD>p-norm of matrix A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dare<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.dare"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.dare</H2>
<B>Solution of discrete-time algebraic Riccati equations</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
Function <b>dare</b> computes the solution <b>X</b> of the discrete-time
algebraic Riccati equation
</p>
<blockquote><pre>
<b>X</b> = <b>A</b>'*<b>X</b>*<b>A</b> - <b>A</b>'*<b>X</b>*<b>B</b>*(<b>R</b> + <b>B</b>'*<b>X</b>*<b>B</b>)<sup>-1</sup>*<b>B</b>'*<b>X</b>*<b>A</b> + <b>Q</b>
</pre></blockquote>
<p>
using the Schur vector approach proposed by Laub [1].
</p>
<p>
It is assumed that <b>Q</b> is symmetric and positve semidefinite and <b>R</b>
is symmetric, nonsingular and positive definite, (<b>A</b>,<b>B</b>) is stabilizable
and (<b>A</b>,<b>Q</b>) is detectable.
<b>The assumptions are not checked in this function</b>
</p>

<p>
The assumptions guarantee that the Hamiltonian matrix
</p>
<blockquote><pre>
<b>H</b> = [<b>A</b><sup>-1</sup>, -<b>A</b><sup>-1</sup>*<b>G</b>; <b>Q</b>*<b>A</b><sup>-1</sup>, <b>A</b>' + <b>Q</b>*<b>A</b><sup>-1</sup>*<b>G</b> ]
</pre></blockquote>
<p>
with
</p>
<blockquote><pre>
<b>G</b> = <b>B</b>*<b>R</b><sup>-1</sup>*<b>B</b>'
</pre></blockquote>
<p>
has no eigenvalue on the unit circle and can be put
to an ordered real Schur form
</p>
<blockquote><pre>
<b>U</b>'*<b>H</b>*<b>U</b> = <b>X</b> = [<b>S11</b>, <b>S12</b>; <b>0</b>, <b>S22</b>]
</pre></blockquote>
<p>
with orthogonal similarity transformation <b>U</b>. <b>X</b> is ordered in such a way,
that <b>S11</b> contains the n stable eigenvalues of the closed loop system with system matrix
</p>
<blockquote><pre>
<b>A</b> - <b>B</b>*(<b>R</b> + <b>B</b>'*<b>X</b>*<b>B</b>)<sup>-1</sup>  *<b>B</b>'*<b>X</b>*<b>A</b>
</pre></blockquote>
<p>
If <b>U</b> is partitioned to
</p>
<blockquote><pre>
<b>U</b> = [<b>U11</b>, <b>U12</b>; <b>U21</b>, <b>U22</b>]
</pre></blockquote>
<p>
according to <b>X</b>, the solution <b>X</b> can be calculated by
</p>
<blockquote><pre>
<b>X</b>*<b>U11</b> = <b>U21</b>.
</pre></blockquote>

<p>
The algorithm uses LAPACK routines dgehrd (to compute the upper Hessenberg matrix
of <b>H</b>), dorghr (to calculate the orthogonal matrix from the elementary reflectors
as returned from dgehrd), dhseqr (to put transformed <b>H</b> to Schur form and to
calculate the eigenvalues of the closed loop system) and dtrsen (to compute the ordered
real Schur form and matrix <b>U</b>).
</p>

<h4><a name="References">References</a></h4>
<dl>
<dt>&nbsp;[1] Laub A.J. (1979):</dt>
<dd> <b>A Schur Method for Solving Algebraic Riccati equations</b>.
     IEEE Trans. Auto. Contr., AC-24, pp. 913-921.<br>&nbsp;</dd>
</dl>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>R[size(B, 2), size(B, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Q[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>refine</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 1), size(A, 2)]</TD><TD>Orthogonal matrix of the Schur vectors associated to ordered rsf</TD></TR>
<TR><TD>ev[size(A, 1)]</TD><TD>Eigenvalues of the closed loop system</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE det<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.M8e52d84b2b4dbbe1s.detI.png" ALT="Modelica_LinearSystems2.Math.Matrices.det" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.det"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.det</H2>
<B>Determinant of a matrix (computed by LU decomposition)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>det</b>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
This function call returns the determinant of matrix A
computed by a LU decomposition.
Usally, this function should never be used, because
there are nearly always better numerical algorithms
as by computing the determinant. E.g., use function
Matrices.rank</a>
to compute the rank of a matrix.
</p>

<h4>See also</h4>
<p>
Matrices.rank</a>,
Matrices.solve</a>
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>result</TD><TD>Determinant of matrix A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dlyapunov<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.dlyapunov"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.dlyapunov</H2>
<B>Solution of continuous-time Lyapunov equation A&#39;X*A - X = C</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
Function <b>laypunov</b> computes the solution <b>X</b> of the continuous-time
Lyapunov equation
</p>
<blockquote><pre>
<b>X</b><b>A</b> + <b>A</b>'*<b>X</b> = <b>C</b>.
</pre></blockquote>
<p>
using the Schur method for Lyapunov equations proposed by Bartels and Stewart [1].
</p>

<h4><a name="References">References</a></h4>
<dl>
<dt>&nbsp;[1] Bartels, R.H. and Stewart G.W. (1972):</dt>
<dd> <b>Algorithm 432: Solution of the matrix equation AX + XB = C</b>.
     Comm. ACM., Vol. 15, pp. 820-826.<br>&nbsp;</dd>
</dl>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>C[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>eps</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 1), size(A, 2)]</TD><TD>solution of the Lyapunov equation</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dsylvester<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.dsylvester"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.dsylvester</H2>
<B>Solution of discrete-time Sylvester equation A*X*B + sgn*X = C</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
X = Matrices.<b>dsylvester</b>(A, B, C);
   or
X = Matrices.<b>dsylvester</b>(A, B, C, AisHess, BTisSchur, sgn, eps);
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>dsylvester</b> computes the solution <b>X</b> of the discrete-time Sylvester equation
</p>
<blockquote>
  <b>A</b>*<b>X</b>*<b>B</b> + sgn*<b>X</b> = <b>C</b>.
</blockquote>
<p>
where sgn = 1 or sgn = -1. The algorithm applies the Hessenberg-Schur
method proposed by Golub et al [1]. For sgn = -1, the discrete Sylvester
equation is also known as Stein equation:
</p>
<blockquote>
  <b>A</b>*<b>X</b>*<b>B</b> - <b>X</b> + <b>Q</b> = <b>0</b>.
</blockquote>
<p>
In a nutshell, the problem is reduced to the corresponding problem
</p>
<blockquote>
  <b>H</b>*<b>Y</b>*<b>S</b>' + sgn*<b>Y</b> = <b>F</b>.
</blockquote>
<p>
with <b>H</b>=<b>U</b>'*<b>A</b>*<b>U</b> is the Hessenberg form
of <b>A</b> and <b>S</b>=<b>V</b>'*<b>B</b>'*<b>V</b> is the real Schur
form of <b>B</b>', <b>F</b>=<b>U</b>'*<b>C</b>*<b>V</b> and
<b>Y</b>=<b>U</b>*<b>X</b>*<b>V</b>' are appropriate transformations
of <b>C</b> and <b>X</b>. This problem is solved sequently by exploiting
the specific forms of <b>S</b> and <b>H</b>.
Finally, the solution of the the original problem is recovered as
<b>X</b>=<b>U</b>'*<b>Y</b>*<b>V</b>.
</p>
<p>
The boolean inputs "AisHess" and "BTisSchur" indicate to omit one
or both of the transformation to Hessenberg form or Schur form, repectively,
in the case that <b>A</b> and/or <b>B</b> have already Hessenberg form
or Schur, respectively.
</p>

<h4><a name="References">References</a></h4>
<dl>
<dt>&nbsp;[1] Golub, G.H., Nash, S. and Van Loan, C.F. (1979):</dt>
<dd> <b>A Hessenberg-Schur method for the problem AX + XB = C</b>.
     IEEE Transaction on Automatic Control, AC-24, no. 6, pp. 909-913.<br>&nbsp;</dd>
</dl>

<h4>Example</h4>
<blockquote><pre>
  A = [1.0,   2.0,   3.0;
       6.0,   7.0,   8.0;
       9.0,   2.0,   3.0];

  B = [7.0,   2.0,   3.0;
       2.0,   1.0,   2.0;
       3.0,   4.0,   1.0];

  C = [271.0,   135.0,   147.0;
       923.0,   494.0,   482.0;
       578.0,   383.0,   287.0];

  X = discreteSylvester(A, B, C);

results in:
  X = [2.0,   3.0,   6.0;
       4.0,   7.0,   1.0;
       5.0,   3.0,   2.0];
</pre></blockquote>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Square matrix A in A*X*B + sgn*X = C</TD></TR>
<TR><TD>B[:, size(B, 1)]</TD><TD>Square matrix B in A*X*B + sgn*X = C</TD></TR>
<TR><TD>C[size(A, 2), size(B, 1)]</TD><TD>Rectangular matrix C in A*X*B + sgn*X = C</TD></TR>
<TR><TD>AisHess</TD><TD>True if A has already Hessenberg form</TD></TR>
<TR><TD>BTisSchur</TD><TD>True if B&#39; has already real Schur form</TD></TR>
<TR><TD>sgn</TD><TD>Specifies the sign in A*X*B + sgn*X = C</TD></TR>
<TR><TD>eps</TD><TD>Tolerance</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 2), size(B, 1)]</TD><TD>solution of the discrete Sylvester equation A*X*B + sgn*X = C</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE eigenValues<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Mea4e8dbe6499a9cbaluesI.png" ALT="Modelica_LinearSystems2.Math.Matrices.eigenValues" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.eigenValues"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.eigenValues</H2>
<B>Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
                eigenvalues = Matrices.<b>eigenValues</b>(A);
(eigenvalues, eigenvectors) = Matrices.<b>eigenValues</b>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
This function call returns the eigenvalues and
optionally the (right) eigenvectors of a square matrix
<b>A</b>. The first column of "eigenvalues" contains the real and the
second column contains the imaginary part of the eigenvalues.
If the i-th eigenvalue has no imaginary part, then eigenvectors[:,i] is
the corresponding real eigenvector. If the i-th eigenvalue
has an imaginary part, then eigenvalues[i+1,:] is the conjugate complex
eigenvalue and eigenvectors[:,i] is the real and eigenvectors[:,i+1] is the
imaginary part of the eigenvector of the i-th eigenvalue.
With function
Matrices.eigenValueMatrix</a>,
a real block diagonal matrix is constructed from the eigenvalues
such that
</p>
<blockquote><pre>
A = eigenvectors * eigenValueMatrix(eigenvalues) * inv(eigenvectors),
</pre></blockquote>
<p>
provided the eigenvector matrix "eigenvectors" can be inverted
(an inversion is possible, if all eigenvalues are different
and no eigenvalue is zero).
</p>

<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real eval;

<b>algorithm</b>
  eval := Matrices.eigenValues(A);  // eval = [-0.618, 0;
                                    //          8.0  , 0;
                                    //          1.618, 0];
</pre></blockquote>
<p>
i.e., matrix <b>A</b> has the 3 real eigenvalues -0.618, 8, 1.618.
</p>

<h4>See also</h4>
<p>
Matrices.eigenValueMatrix</a>,
Matrices.singularValues</a>
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>eigenvalues[size(A, 1), 2]</TD><TD>Eigenvalues of matrix A (Re: first column, Im: second column)</TD></TR>
<TR><TD>leftEigenvectors[size(A, 1), size(A, 2)]</TD><TD>Real-valued eigenvector matrix</TD></TR>
<TR><TD>rightEigenvectors[size(A, 1), size(A, 2)]</TD><TD>Real-valued eigenvector matrix</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE equalityLeastSquares<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Mea4e8dbe6499a9cbaluesI.png" ALT="Modelica_LinearSystems2.Math.Matrices.equalityLeastSquares" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.equalityLeastSquares"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.equalityLeastSquares</H2>
<B>Solve a linear equality constrained least squares problem</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<b>equalityLeastSquares</b>(A,a,B,b);
</pre></blockquote>

<h4>Description</h4>
<p>
This function returns the
solution <b>x</b> of the linear equality-constrained least squares problem:
</p>
<blockquote>
<p>
min|<b>A</b>*<b>x</b> - <b>a</b>|^2 over <b>x</b>, subject to <b>B</b>*<b>x</b> = <b>b</b>
</p>
</blockquote>

<p>
It is required that the dimensions of A and B fulfill the following
relationship:
</p>

<blockquote>
size(B,1) &le; size(A,2) &le; size(A,1) + size(B,1)
</blockquote>

<h4>Note</h4>
<p>
The solution is computed with the LAPACK function "dgglse"
using the generalized RQ factorization under the assumptions that
B has full row rank (= size(B,1)) and the matrix [A;B] has
full column rank (= size(A,2)). In this case, the problem
has a unique solution.
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Minimize |A*x - a|^2</TD></TR>
<TR><TD>a[size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[:, size(A, 2)]</TD><TD>Subject to B*x=b</TD></TR>
<TR><TD>b[size(B, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>x[size(A, 2)]</TD><TD>Solution vector</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fliplr<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.fliplr"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.fliplr</H2>
<B>Flip the columns of a matrix in left/right direction</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix to be fliped</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Aflip[size(A, 1), size(A, 2)]</TD><TD>Fliped matrix</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE flipud<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.flipud"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.flipud</H2>
<B>Flip the columns of a matrix in up/down direction</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix to be flipped</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Aflip[size(A, 1), size(A, 2)]</TD><TD>Flipped matrix</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fromFile<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.fromFile"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.fromFile</H2>
<B>Read matrix from a matlab file</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>fileName</TD><TD>&nbsp;</TD></TR>
<TR><TD>matrixName</TD><TD>Name of the matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[n, m]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE generalizedEigenvaluesTriangular<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.generalizedEigenvaluesTriangular"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.generalizedEigenvaluesTriangular</H2>
<B>Compute invariant zeros of linear state space system with a generalized system matrix [A, B, C, D] which is of upper Hessenberg form</B><p>
<P><H3>Information</H3></P>
<PRE>This function is an interface to LAPACK routine DHGEQZ to calculate invariant
zeros of systems with generalized system matrices of upper Hessenberg form.
DHGEQZ is described below:



     Purpose
   ==========================================================

   DHGEQZ implements a single-/double-shift version of the QZ method for
   finding the generalized eigenvalues

   w(j)=(ALPHAR(j) + i*ALPHAI(j))/BETAR(j)   of the equation

        det( A - w(i) B ) = 0

   In addition, the pair A,B may be reduced to generalized Schur form:
   B is upper triangular, and A is block upper triangular, where the
   diagonal blocks are either 1-by-1 or 2-by-2, the 2-by-2 blocks having
   complex generalized eigenvalues (see the description of the argument
   JOB.)

   If JOB=&#39;S&#39;, then the pair (A,B) is simultaneously reduced to Schur
   form by applying one orthogonal tranformation (usually called Q) on
   the left and another (usually called Z) on the right.  The 2-by-2
   upper-triangular diagonal blocks of B corresponding to 2-by-2 blocks
   of A will be reduced to positive diagonal matrices.  (I.e.,
   if A(j+1,j) is non-zero, then B(j+1,j)=B(j,j+1)=0 and B(j,j) and
   B(j+1,j+1) will be positive.)

   If JOB=&#39;E&#39;, then at each iteration, the same transformations
   are computed, but they are only applied to those parts of A and B
   which are needed to compute ALPHAR, ALPHAI, and BETAR.

   If JOB=&#39;S&#39; and COMPQ and COMPZ are &#39;V&#39; or &#39;I&#39;, then the orthogonal
   transformations used to reduce (A,B) are accumulated into the arrays
   Q and Z s.t.:

        Q(in) A(in) Z(in)* = Q(out) A(out) Z(out)*
        Q(in) B(in) Z(in)* = Q(out) B(out) Z(out)*

   Ref: C.B. Moler &amp; G.W. Stewart, &quot;An Algorithm for Generalized Matrix
        Eigenvalue Problems&quot;, SIAM J. Numer. Anal., 10(1973),
        pp. 241--256.

   Arguments
   =========

   JOB     (input) CHARACTER*1
           = &#39;E&#39;: compute only ALPHAR, ALPHAI, and BETA.  A and B will
                  not necessarily be put into generalized Schur form.
           = &#39;S&#39;: put A and B into generalized Schur form, as well
                  as computing ALPHAR, ALPHAI, and BETA.

   COMPQ   (input) CHARACTER*1
           = &#39;N&#39;: do not modify Q.
           = &#39;V&#39;: multiply the array Q on the right by the transpose of
                  the orthogonal tranformation that is applied to the
                  left side of A and B to reduce them to Schur form.
           = &#39;I&#39;: like COMPQ=&#39;V&#39;, except that Q will be initialized to
                  the identity first.

   COMPZ   (input) CHARACTER*1
           = &#39;N&#39;: do not modify Z.
           = &#39;V&#39;: multiply the array Z on the right by the orthogonal
                  tranformation that is applied to the right side of
                  A and B to reduce them to Schur form.
           = &#39;I&#39;: like COMPZ=&#39;V&#39;, except that Z will be initialized to
                  the identity first.

   N       (input) INTEGER
           The order of the matrices A, B, Q, and Z.  N &gt;= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           It is assumed that A is already upper triangular in rows and
           columns 1:ILO-1 and IHI+1:N.
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
           On entry, the N-by-N upper Hessenberg matrix A.  Elements
           below the subdiagonal must be zero.
           If JOB=&#39;S&#39;, then on exit A and B will have been
              simultaneously reduced to generalized Schur form.
           If JOB=&#39;E&#39;, then on exit A will have been destroyed.
              The diagonal blocks will be correct, but the off-diagonal
              portion will be meaningless.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max( 1, N ).

   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
           On entry, the N-by-N upper triangular matrix B.  Elements
           below the diagonal must be zero.  2-by-2 blocks in B
           corresponding to 2-by-2 blocks in A will be reduced to
           positive diagonal form.  (I.e., if A(j+1,j) is non-zero,
           then B(j+1,j)=B(j,j+1)=0 and B(j,j) and B(j+1,j+1) will be
           positive.)
           If JOB=&#39;S&#39;, then on exit A and B will have been
              simultaneously reduced to Schur form.
           If JOB=&#39;E&#39;, then on exit B will have been destroyed.
              Elements corresponding to diagonal blocks of A will be
              correct, but the off-diagonal portion will be meaningless.

   LDB     (input) INTEGER
           The leading dimension of the array B.  LDB &gt;= max( 1, N ).

   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
           ALPHAR(1:N) will be set to real parts of the diagonal
           elements of A that would result from reducing A and B to
           Schur form and then further reducing them both to triangular
           form using unitary transformations s.t. the diagonal of B
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=A(j,j).
           Note that the (real or complex) values
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
           generalized eigenvalues of the matrix pencil A - wB.

   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
           ALPHAI(1:N) will be set to imaginary parts of the diagonal
           elements of A that would result from reducing A and B to
           Schur form and then further reducing them both to triangular
           form using unitary transformations s.t. the diagonal of B
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=0.
           Note that the (real or complex) values
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
           generalized eigenvalues of the matrix pencil A - wB.

   BETA    (output) DOUBLE PRECISION array, dimension (N)
           BETA(1:N) will be set to the (real) diagonal elements of B
           that would result from reducing A and B to Schur form and
           then further reducing them both to triangular form using
           unitary transformations s.t. the diagonal of B was
           non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
           (i.e., A(j+1,j)=A(j,j+1)=0), then BETA(j)=B(j,j).
           Note that the (real or complex) values
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
           generalized eigenvalues of the matrix pencil A - wB.
           (Note that BETA(1:N) will always be non-negative, and no
           BETAI is necessary.)

   Q       (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
           If COMPQ=&#39;N&#39;, then Q will not be referenced.
           If COMPQ=&#39;V&#39; or &#39;I&#39;, then the transpose of the orthogonal
              transformations which are applied to A and B on the left
              will be applied to the array Q on the right.

   LDQ     (input) INTEGER
           The leading dimension of the array Q.  LDQ &gt;= 1.
           If COMPQ=&#39;V&#39; or &#39;I&#39;, then LDQ &gt;= N.

   Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
           If COMPZ=&#39;N&#39;, then Z will not be referenced.
           If COMPZ=&#39;V&#39; or &#39;I&#39;, then the orthogonal transformations
              which are applied to A and B on the right will be applied
              to the array Z on the right.

   LDZ     (input) INTEGER
           The leading dimension of the array Z.  LDZ &gt;= 1.
           If COMPZ=&#39;V&#39; or &#39;I&#39;, then LDZ &gt;= N.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO &gt;= 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK &gt;= max(1,N).

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0: successful exit
           &lt; 0: if INFO = -i, the i-th argument had an illegal value
           = 1,...,N: the QZ iteration did not converge.  (A,B) is not
                      in Schur form, but ALPHAR(i), ALPHAI(i), and
                      BETA(i), i=INFO+1,...,N should be correct.
           = N+1,...,2*N: the shift calculation failed.  (A,B) is not
                      in Schur form, but ALPHAR(i), ALPHAI(i), and
                      BETA(i), i=INFO-N+1,...,N should be correct.
           &gt; 2*N:     various &quot;impossible&quot; errors.

   Further Details
   ===============

   Iteration counters:

   JITER  -- counts iterations.
   IITER  -- counts iterations run since ILAST was last
             changed.  This is therefore reset only when a 1-by-1 or
             2-by-2 block deflates off the bottom.

   =====================================================================
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>alphaReal[size(A, 1)]</TD><TD>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</TD></TR>
<TR><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of alpha</TD></TR>
<TR><TD>beta[size(A, 1)]</TD><TD>Denominator of eigenvalue</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE hessenberg<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.hessenberg"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.hessenberg</H2>
<B>Transform a matrix to upper Hessenberg form</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
     H = Matrices.<b>hessenberg</b>(A);
(H, U) = Matrices.<b>hessenberg</b>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>hessenberg</b> computes the Hessenberg matrix <b>H</b>
of matrix <b>A</b> as well as the orthogonal transformation matrix
<b>U</b> that holds <b>H</b> = <b>U</b>'*<b>A</b>*<b>U</b>.
The Hessenberg form of a matrix is computed by repeated Householder
similarity transformation. The elementary reflectors and the corresponding
scalar factors are provided by function "Utilities.toUpperHessenberg()".
The transformation matrix <b>U</b> is then computed by
LAPACK.dorghr</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  A  = [1, 2,  3;
        6, 5,  4;
        1, 0,  0];

  (H, U) = hessenberg(A);

  results in:

  H = [1.0,  -2.466,  2.630;
      -6.083, 5.514, -3.081;
       0.0,   0.919, -0.514]

  U = [1.0,    0.0,      0.0;
       0.0,   -0.9864,  -0.1644;
       0.0,   -0.1644,   0.9864]

  and therefore,

  u*H*transpose(U) = [1.0, 2.0, 3.0;
                      6.0, 5.0, 4.0;
                      1.0, 0.0, 0.0]
</pre></blockquote>

<h4>See also</h4>
<p>
Matrices.Utilities.toUpperHessenberg</a>
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Square matrix A</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>H[size(A, 1), size(A, 2)]</TD><TD>Hessenberg form of A</TD></TR>
<TR><TD>U[size(A, 1), size(A, 2)]</TD><TD>Transformation matrix</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE householderReflexion<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.householderReflexion"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.householderReflexion</H2>
<B>Reflect each of the vectors ai of matrix  A=[a1, a2, ..., an] on a plane with orthogonal vector u</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>householderReflection</b>(A,u);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the Housholder reflection (transformation)
</p>
<blockquote>
<b>Ar</b> = <b>Q</b>*<b>A</b>
</blockquote>
<p>
with
</p>
<blockquote>
<b>Q</b> = <b>I</b> -2*<b>u</b>*<b>u</b>'/(<b>u</b>'*<b>u</b>)
</blockquote>
<p>
where <b>u</b>*<b>u</b> is housholder vector, i.e. the normal vector of the reflection plane.
</p>
<p>
Householder reflection is widely used in numerical linear algebra, e.g. to perform QR decompositions.
</p>

<h4>Example</h4>
<blockquote><pre>
// First step of QR decomposition
  import   Modelica.Math.Vectors.Utilities;

  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real Ar[3,3];
  Real u[:];

  u=Utilities.householderVector(A[:,1],{1,0,0});
  // u={ = {0.763, 0.646, 0}
  Ar=householderReflexion(A,u);
 // Ar = [-6.0828,   -5.2608,   -4.4388;
 //        0.0,      -1.1508,   -2.3016;
 //        0.0,       2.0,       0.0]

</pre></blockquote>

<h4>See also</h4>
<p>
Matrices.housholderSimilarityTransformation</a>
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Rectangular matrix</TD></TR>
<TR><TD>u[size(A, 1)]</TD><TD>Householder vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>RA[size(A, 1), size(A, 2)]</TD><TD>Reflexion of A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE householderSimilarityTransformation<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.householderSimilarityTransformation"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.householderSimilarityTransformation</H2>
<B>Calculate the similarity transformation S*A*S of matrix A with symmetric householder matrix S = I - 2u*u&#39;</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>householderSimilarityTransformation</b>(A,u);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the Housholder similarity transformation
</p>
<blockquote>
  <b>As</b> = <b>S</b>*<b>A</b>*<b>S</b>
</blockquote>
<p>
with
</p>
<blockquote>
  <b>S</b> = <b>I</b> -2*<b>u</b>*<b>u</b>'/(<b>u</b>'*<b>u</b>).
</blockquote>
<p>
This transformation is widely used for transforming non-symmetric matrices to a Hessenberg form.
</p>

<h4>Example</h4>
<blockquote><pre>
// First step of Hessenberg decomposition
  import   Modelica.Math.Vectors.Utilities;

  Real A[4,4] = [1,2,3,4;
                 3,4,5,6;
                 9,8,7,6;
                 1,2,0,0];
  Real Ar[4,4];
  Real u[4]={0,0,0,0};

  u[2:4]=Utilities.householderVector(A[2:4,1],{1,0,0});
  // u= = {0, 0.8107, 0.5819, 0.0647}
  Ar=householderSimilarityTransformation(A,u);
 //  Ar = [1.0,     -3.8787,    -1.2193,    3.531;
          -9.5394, 11.3407,      6.4336,   -5.9243;
           0.0,     3.1307,      0.7525,   -3.3670;
           0.0,     0.8021,     -1.1656,   -1.0932]
</pre></blockquote>

<h4>See also</h4>
<p>
Matrices.housholderReflection</a>
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Square matrix A</TD></TR>
<TR><TD>u[size(A, 1)]</TD><TD>Householder vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>SAS[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE leastSquares2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.M37a92c25c3f621edares2I.png" ALT="Modelica_LinearSystems2.Math.Matrices.leastSquares2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.leastSquares2"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.leastSquares2</H2>
<B>Solve overdetermined or underdetermined real system of linear equations A*X=B in a least squares sense (A may be rank deficient)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
X = Matrices.<b>leastSquares2</b>(A,B);
</pre></blockquote>


<h4>Description</h4>
<p>
Returns a solution of equation A*X = B in a least
square sense (A may be rank deficient):
</p>
<pre>
  minimize | A*X - B |
</pre>

<p>
Several different cases can be distinguished (note, <b>rank</b> is an
output argument of this function):
</p>

<p>
<b>size(A,1) = size(A,2)</b>
</p>

<p> A solution is returned for a regular, as well as a singular matrix A:
</p>

<ul>
<li> <b>rank</b> = size(A,1):<br>
     A is <b>regular</b> and the returned solution X fulfills the equation
     A*X = B uniquely.</li>

<li> <b>rank</b> &lt; size(A,1):<br>
     A is <b>singular</b> and no unique solution for equation A*X = B exists.
     <ul>
     <li>  If an infinite number of solutions exists, the one is selected that fulfills
           the equation and at the same time has the minimum norm |x| for all solution
           vectors that fulfill the equation.</li>
     <li>  If no solution exists, X is selected such that |A*X - B| is as small as
           possible (but A*X - B is not zero).</li>
     </ul>
</ul>

<p>
<b>size(A,1) &gt; size(A,2):</b>
</p>

<p>
The equation A*X = B has no unique solution. The solution X is selected such that
|A*X - B| is as small as possible. If rank = size(A,2), this minimum norm solution is
unique. If rank &lt; size(A,2), there are an infinite number of solutions leading to the
same minimum value of |A*X - B|. From these infinite number of solutions, the one with the
minimum norm |X| is selected. This gives a unique solution that minimizes both
|A*X - B| and |X|.
</p>

<p>
<b>size(A,1) &lt; size(A,2):</b>
</p>

<ul>
<li> <b>rank</b> = size(A,1):<br>
     There are an infinite number of solutions that fulfill the equation A*X = B.
     From this infinite number, the unique solution is selected that minimizes |X|.
     </li>

<li> <b>rank</b> &lt; size(A,1):<br>
     There is either no solution of equation A*X = B, or there are again an infinite
     number of solutions. The unique solution X is returned that minimizes
      both |A*X - B| and |X|.</li>
</ul>


<h4>Note</h4>
<p>
The solution is computed with the LAPACK function "dgelsx",
i.e., QR or LQ factorization of A with column pivoting.
</p>


<h4>Algorithmic details</h4>
<p>
The function first computes a QR factorization with column pivoting:
</p>

<pre>
      A * P = Q * [ R11 R12 ]
                  [  0  R22 ]
</pre>

<p>
with R11 defined as the largest leading submatrix whose estimated
condition number is less than 1/rcond.  The order of R11, <b>rank</b>,
is the effective rank of A.
</p>

<p>
Then, R22 is considered to be negligible, and R12 is annihilated
by orthogonal transformations from the right, arriving at the
complete orthogonal factorization:
</p>

<pre>
     A * P = Q * [ T11 0 ] * Z
                 [  0  0 ]
</pre>

<p>
The minimum-norm solution is then
</p>

<pre>
     X = P * Z' [ inv(T11)*Q1'*B ]
                [        0       ]
</pre>

<p>
where Q1 consists of the first "rank" columns of Q.
</p>


<h4>See also</h4>
<p>
Matrices.leastSquares</a>
(same as leastSquares2, but with a right hand side vector),
Matrices.solve2</a>
(for square, regular matrices A)
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix A</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>Matrix B</TD></TR>
<TR><TD>rcond</TD><TD>Reciprocal condition number to estimate rank of A</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 2), size(B, 2)]</TD><TD>Matrix X such that min|A*X-B|^2 if size(A,1) &gt;= size(A,2) or min|X|^2 and A*X=B, if size(A,1) &lt; size(A,2)</TD></TR>
<TR><TD>rank</TD><TD>Rank of A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE leastSquares<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.M37a92c25c3f621edares2I.png" ALT="Modelica_LinearSystems2.Math.Matrices.leastSquares" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.leastSquares"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.leastSquares</H2>
<B>Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<b>leastSquares</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
A linear system of equations A*x = b has no solutions or infinitely
many solutions if A is not square. Function "leastSquares" returns
a solution in a least squarse sense:
</p>
<pre>
  size(A,1) &gt; size(A,2):  returns x such that |A*x - b|^2 is a minimum
  size(A,1) = size(A,2):  returns x such that A*x = b
  size(A,1) &lt; size(A,2):  returns x such that |x|^2 is a minimum for all
                          vectors x that fulfill A*x = b
</pre>

<h4>Note</h4>
<p>
The solution is computed with the LAPACK function "dgelsx",
i.e., QR or LQ factorization of A with column pivoting.
If A does not have full rank,
the solution is not unique and from the infinitely many solutions
the one is selected that minimizes both |x|^2 and |A*x - b|^2.
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix A</TD></TR>
<TR><TD>b[size(A, 1)]</TD><TD>Vector b</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>x[size(A, 2)]</TD><TD>Vector x such that min|A*x-b|^2 if size(A,1) &gt;= size(A,2) or min|x|^2 and A*x=b, if size(A,1) &lt; size(A,2)</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE lyapunov<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.lyapunov"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.lyapunov</H2>
<B>Solution of continuous-time Lyapunov equation X*A + A&#39;*X = C</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
Function <b>laypunov</b> computes the solution <b>X</b> of the continuous-time Lyapunov equation
</p>
<blockquote><pre>
<b>X</b><b>A</b> + <b>A</b>'*<b>X</b> = <b>C</b>.
</pre></blockquote>
<p>
using the Schur method for Lyapunov equations proposed by Bartels and Stewart [1].
</p>

<h4><a name="References">References</a></h4>
<dl>
<dt>&nbsp;[1] Bartels, R.H. and Stewart G.W. (1972):</dt>
<dd> <b>Algorithm 432: Solution of the matrix equation AX + XB = C</b>.
     Comm. ACM., Vol. 15, pp. 820-826.<br>&nbsp;</dd>
</dl>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>C[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>eps</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 1), size(A, 2)]</TD><TD>solution of the Lyapunov equation</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LQ<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LQ"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.LQ</H2>
<B>LQ decomposition of a rectangular matrix without column pivoting (A = L*Q)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
(Q,R,p) = Matrices.<b>QR</b>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
This function returns the QR decomposition of
a rectangular matrix <b>A</b> (the number of columns of <b>A</b>
must be less than or equal to the number of rows):
</p>
<blockquote>
<p>
<b>Q</b>*<b>R</b> = <b>A</b>[:,<b>p</b>]
</p>
</blockquote>
<p>
where <b>Q</b> is a rectangular matrix that has orthonormal columns and
has the same size as A (<b>Q</b><sup>T</sup><b>Q</b>=<b>I</b>),
<b>R</b> is a square, upper triangular matrix and <b>p</b> is a permutation
vector. Matrix <b>R</b> has the following important properties:
</p>
<ul>
<li> The absolute value of a diagonal element of <b>R</b> is the largest
     value in this row, i.e.,
     abs(R[i,i]) &ge; abs(R[i,j]).</li>
<li> The diagonal elements of <b>R</b> are sorted according to size, such that
     the largest absolute value is abs(R[1,1]) and
     abs(R[i,i]) &ge; abs(R[j,j]) with i &lt; j. </li>
</ul>
<p>
This means that if abs(R[i,i]) &le; &epsilon; then abs(R[j,k]) &le; &epsilon;
for j &ge; i, i.e., the i-th row up to the last row of <b>R</b> have
small elements and can be treated as being zero.
This allows to, e.g., estimate the row-rank
of <b>R</b> (which is the same row-rank as <b>A</b>). Furthermore,
<b>R</b> can be partitioned in two parts
</p>
<blockquote>
<pre>
<b>A</b>[:,<b>p</b>] = <b>Q</b> * [<b>R</b><sub>1</sub>, <b>R</b><sub>2</sub>;
              <b>0</b>,  <b>0</b>]
</pre>
</blockquote>
<p>
where <b>R</b><sub>1</sub> is a regular, upper triangular matrix.
</p>

<h4>Note</h4>
<p>
The solution is computed with the LAPACK functions "dgeqp3"
and "dorgqr", i.e., by Housholder transformations with
column pivoting. If <b>Q</b> is not needed, the function may be
called as: <code>(,R,p) = QR(A)</code>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real R[3,3];
<b>algorithm</b>
  (,R) := Matrices.QR(A);  // R = [-7.07.., -4.24.., -3.67..;
                                    0     , -1.73.., -0.23..;
                                    0     ,  0     ,  0.65..];
</pre></blockquote>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Rectangular matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>L[size(A, 1), size(A, 1)]</TD><TD>Rectangular matrix containing the lower triangular matrix</TD></TR>
<TR><TD>Q[size(A, 1), size(A, 2)]</TD><TD>Rectangular matrix with orthonormal columns such that L*Q=A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LUI.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.LU"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.LU</H2>
<B>LU decomposition of square or rectangular matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
(LU, pivots)       = Matrices.<b>LU</b>(A);
(LU, pivots, info) = Matrices.<b>LU</b>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
This function call returns the
LU decomposition of a "Real[m,n]" matrix A, i.e.,
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b> = <b>A</b>
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
Matrices <b>L</b> and <b>U</b> are stored in the returned
matrix <code>LU</code> (the diagonal of <b>L</b> is not stored).
With the companion function
Matrices.LU_solve</a>,
this decomposition can be used to solve
linear systems (<b>P</b>*<b>L</b>*<b>U</b>)*<b>x</b> = <b>b</b> with different right
hand side vectors <b>b</b>. If a linear system of equations with
just one right hand side vector <b>b</b> shall be solved, it is
more convenient to just use the function
Matrices.solve</a>.
</p>
<p>
The optional third (Integer) output argument has the following meaning:
</p>
<blockquote>
<table border=0 cellspacing=0 cellpadding=2>
  <tr><td valign="top">info = 0:</td>
      <td valign="top">Successful exit</td></tr>
  <tr><td valign="top">info &gt; 0:</td>
      <td valign="top" width="350">If info = i then U[i,i] is exactly zero. The factorization
          has been completed, but the factor U is exactly
          singular, and division by zero will occur if it is used
          to solve a system of equations.</td></tr>
</table>
</blockquote>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of
matrix A was interchanged with row pivots[i].
</p>

<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real b1[3] = {10,22,12};
  Real b2[3] = { 7,13,10};
  Real    LU[3,3];
  Integer pivots[3];
  Real    x1[3];
  Real    x2[3];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
  x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
</pre></blockquote>

<h4>See also</h4>
<p>
Matrices.LU_solve</a>,
Matrices.solve</a>
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Square or rectangular matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>LU[size(A, 1), size(A, 2)]</TD><TD>L,U factors (used with LU_solve(..))</TD></TR>
<TR><TD>pivots[min(size(A, 1), size(A, 2))]</TD><TD>Pivot indices (used with LU_solve(..))</TD></TR>
<TR><TD>info</TD><TD>Information</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU_solve<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LUI.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU_solve" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.LU_solve"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.LU_solve</H2>
<B>Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>LU_solve</b>(LU, pivots, b);
</pre></blockquote>

<h4>Description</h4>
<p>
This function call returns the
solution <b>x</b> of the linear systems of equations
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b>*<b>x</b> = <b>b</b>;
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
The matrices of this decomposition are computed with function
Matrices.LU</a> that
returns arguments <code>LU</code> and <code>pivots</code>
used as input arguments of <code>Matrices.LU_solve</code>.
With <code>Matrices.LU</code> and <code>Matrices.LU_solve</code>
it is possible to efficiently solve linear systems
with different right hand side vectors. If a linear system of equations with
just one right hand side vector shall be solved, it is
more convenient to just use the function
Matrices.solve</a>.
</p>
<p>
If a unique solution <b>x</b> does not exist (since the
LU decomposition is singular), an exception is raised.
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of
matrix A was interchanged with row pivots[i].
</p>

<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real b1[3] = {10,22,12};
  Real b2[3] = { 7,13,10};
  Real    LU[3,3];
  Integer pivots[3];
  Real    x1[3];
  Real    x2[3];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
  x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
</pre></blockquote>

<h4>See also</h4>
<p>
Matrices.LU</a>,
Matrices.solve</a>
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>LU[:, size(LU, 1)]</TD><TD>L,U factors of Matrices.LU(..) for a square matrix</TD></TR>
<TR><TD>pivots[size(LU, 1)]</TD><TD>Pivots indices of Matrices.LU(..)</TD></TR>
<TR><TD>b[size(LU, 1)]</TD><TD>Right hand side vector of P*L*U*x=b</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>x[size(b, 1)]</TD><TD>Solution vector such that P*L*U*x = b</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU_solve2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LU_solve2"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.LU_solve2</H2>
<B>Solve real system of linear equations P*L*U*X=B with a B vector and an LU decomposition (from LU(..))</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>LU_solve2</b>(LU, pivots, B);
</pre></blockquote>

<h4>Description</h4>
<p>
This function call returns the
solution <b>x</b> of the linear systems of equations
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b>*<b>X</b> = <b>B</b>;
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
The matrices of this decomposition are computed with function
Matrices.LU</a> that
returns arguments <code>LU</code> and <code>pivots</code>
used as input arguments of <code>Matrices.LU_solve</code>.
With <code>Matrices.LU</code> and <code>Matrices.LU_solve</code>
it is possible to efficiently solve linear systems
with different right hand side <b>matrices</b>. If a linear system of equations with
just one right hand side matrix shall be solved, it is
more convenient to just use the function
Matrices.solve2</a>.
</p>
<p>
If a unique solution <b>X</b> does not exist (since the
LU decomposition is singular), an exception is raised.
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of
matrix A was interchanged with row pivots[i].
</p>

<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real B1[3] = [10, 20;
                22, 44;
                12, 24];
  Real B2[3] = [ 7, 14;
                13, 26;
                10, 20];
  Real    LU[3,3];
  Integer pivots[3];
  Real    X1[3,2];
  Real    X2[3,2];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  X1 := Matrices.LU_solve2(LU, pivots, B1);  /* X1 = [3, 6;
                                                      2, 4;
                                                      1, 2] */
  X2 := Matrices.LU_solve2(LU, pivots, B2);  /* X2 = [1, 2;
                                                      0, 0;
                                                      2, 4] */
</pre></blockquote>

<h4>See also</h4>
<p>
Matrices.LU</a>,
Matrices.solve2</a>
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>LU[:, size(LU, 1)]</TD><TD>L,U factors of Matrices.LU(..) for a square matrix</TD></TR>
<TR><TD>pivots[size(LU, 1)]</TD><TD>Pivots indices of Matrices.LU(..)</TD></TR>
<TR><TD>B[size(LU, 1), :]</TD><TD>Right hand side matrix of P*L*U*X=B</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(B, 1), size(B, 2)]</TD><TD>Solution matrix such that P*L*U*X = B</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE toUpperHessenberg<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.toUpperHessenberg"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.toUpperHessenberg</H2>
<B>Transform a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
                H = Matrices.<b>toUpperHessenberg</b>(A);
(H, V, tau, info) = Matrices.<b>toUpperHessenberg</b>(A,ilo, ihi);
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>toUpperHessenberg</b> computes a upper Hessenberg form <b>H</b>
of a matrix <b>A</b> by orthogonal similarity transformation:
<b>Q</b>' * <b>A</b> * <b>Q</b> = <b>H</b>. It calls LAPACK function DGEHRD.
See <A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgehrd"
>Matrices.LAPACK.dgehrd</a>
for more information about the additional outputs V, tau, info and
inputs ilo, ihi for more information.
</p>

<h4>Example</h4>
<blockquote><pre>
  A  = [1, 2,  3;
        6, 5,  4;
        1, 0,  0];

  H = toUpperHessenberg(A);

  results in:

  H = [1.0,  -2.466,  2.630;
      -6.083, 5.514, -3.081;
       0.0,   0.919, -0.514]
</pre></blockquote>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Square matrix A</TD></TR>
<TR><TD>ilo</TD><TD>Lowest index where the original matrix had been Hessenbergform</TD></TR>
<TR><TD>ihi</TD><TD>Highest index where the original matrix had been Hessenbergform</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>H[size(A, 1), size(A, 2)]</TD><TD>Upper Hessenberg form</TD></TR>
<TR><TD>V[size(A, 1), size(A, 2)]</TD><TD>V=[v1,v2,..vn-1,0] with vi are vectors which define the elementary reflectors</TD></TR>
<TR><TD>tau[max(0, size(A, 1) - 1)]</TD><TD>Scalar factors of the elementary reflectors</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE norm<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Md5be543069be5488.normI.png" ALT="Modelica_LinearSystems2.Math.Matrices.norm" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.norm"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.norm</H2>
<B>Returns the norm of a matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>norm</b>(A);
Matrices.<b>norm</b>(A, p=2);
</pre></blockquote>

<h4>Description</h4>
<p>
The function call "<code>Matrices.norm(A)</code>" returns the
2-norm of matrix A, i.e., the largest singular value of A.<br>
The function call "<code>Matrices.norm(A, p)</code>" returns the
p-norm of matrix A. The only allowed values for p are
</p>
<ul>
<li> "p=1": the largest column sum of A</li>
<li> "p=2": the largest singular value of A</li>
<li> "p=Modelica.Constants.inf": the largest row sum of A</li>
</ul>
<p>
Note, for any matrices A1, A2 the following inequality holds:
</p>
<blockquote><pre>
Matrices.<b>norm</b>(A1+A2,p) &le; Matrices.<b>norm</b>(A1,p) + Matrices.<b>norm</b>(A2,p)
</pre></blockquote>
<p>
Note, for any matrix A and vector v the following inequality holds:
</p>
<blockquote><pre>
Vectors.<b>norm</b>(A*v,p) &le; Matrices.<b>norm</b>(A,p)*Vectors.<b>norm</b>(A,p)
</pre></blockquote>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Input matrix</TD></TR>
<TR><TD>p</TD><TD>Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>result</TD><TD>p-norm of matrix A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE nullspace<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Md5be543069be5488.normI.png" ALT="Modelica_LinearSystems2.Math.Matrices.nullspace" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.nullspace"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.nullspace</H2>
<B>Orthonormal nullspace of a matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
           Z = Matrices.<b>nullspace</b>(A);
(Z, nullity) = Matrices.<b>nullspace</b>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
This function calculates an orthonormal basis <b>Z</b>=[<b>z</b>_1, <b>z</b>_2, ...]
of the nullspace of a matrix <b>A</b>, i.e. <b>A</b>*<b>z</b>_i=0.
The nullspace is obtained by svd method. That is, matrix <b>A</b> is decomposed
into the matrices <b>S</b>, <b>U</b>, <b>V</b>:
</p>
<blockquote>
  <b>A</b> = <b>U</b><b>S</b><b>V</b><sup>T</sup>
</blockquote>
<p>
with the orthonormal matrices <b>U</b> and <b>V</b> and the matrix <b>S</b> with
</p>
<blockquote>
  <b>S</b> = [<b>S</b>1, <b>0</b>]
  <b>S</b>1 = [diag(s); <b>0</b>]
</blockquote>
<p>
with the singular values <b>s</b>={s1, s2, ..., sr} of <b>A</b> and r=rank(<b>A</b>).
Note, that <b>S</b> has the same size as <b>A</b>. Since <b>U</b> and <b>V</b> are
orthonormal, we may write
</p>
<blockquote>
  <b>U</b><sup>T</sup>*<b>A</b>*<b>V</b> = [<b>S</b>1, <b>0</b>].
</blockquote>
<p>
Matrix <b>S</b>1 obviously has full column rank and therefore, the left n-r rows
(n is the number of columns of <b>A</b> or <b>S</b>) of matrix <b>V</b> span
a nullspace of <b>A</b>.
</p>
<p>
The nullity of matrix <b>A</b> is the dimension of the nullspace of <b>A</b>.
In view of the above, it becomes clear that nullity holds
</p>
<blockquote><pre>
nullity = n - r
</pre></blockquote>
<p>
with
</p>
<blockquote>
n = number of columns of matrix <b>A</b> and <br>
r = rank(<b>A</b>).
</blockquote>

<h4>Example</h4>
<blockquote><pre>
  A = [1, 2,  3, 1;
       3, 4,  5, 2;
      -1, 2, -3, 3];
  (Z, nullity) = nullspace(A);

  results in:

  Z=[0.1715;
    -0.686;
     0.1715;
     0.686]

  nullity = 1
</pre></blockquote>

<h4>See also</h4>
<p>
Matrices.singularValues</a>
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Input matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Z[size(A, 2), :]</TD><TD>Orthonormal nullspace of matrix A</TD></TR>
<TR><TD>nullity</TD><TD>Nullity, i.e. the dimension of the nullspace</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE orthogonalQ<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.orthogonalQ"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.orthogonalQ</H2>
<B>Generates a real orthogonal matrix Q defined as the product of IHI-ILO elementary reflectors</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function generates a real orthogonal matrix Q which is defined as the product
of IHI-ILO elementary reflectors of order N, as returned by DGEHRD.
</p>

<pre>
Lapack documentation:

   Purpose
   =======

   DORGHR generates a real orthogonal matrix Q which is defined as the
   product of IHI-ILO elementary reflectors of order N, as returned by
   DGEHRD:

   Q = H(ilo) H(ilo+1) . . . H(ihi-1).

   Arguments
   =========

   N       (input) INTEGER
           The order of the matrix Q. N &gt;= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           ILO and IHI must have the same values as in the previous call
           of DGEHRD. Q is equal to the unit matrix except in the
           submatrix Q(ilo+1:ihi,ilo+1:ihi).
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the vectors which define the elementary reflectors,
           as returned by DGEHRD.
           On exit, the N-by-N orthogonal matrix Q.

   LDA     (input) INTEGER
           The leading dimension of the array A. LDA &gt;= max(1,N).

   TAU     (input) DOUBLE PRECISION array, dimension (N-1)
           TAU(i) must contain the scalar factor of the elementary
   ), as returned by DGEHRD.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK. LWORK &gt;= IHI-ILO.
           For optimum performance LWORK &gt;= (IHI-ILO)*NB, where NB is
           the optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value

   =====================================================================

</pre>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>tau[size(A, 1) - 1]</TD><TD>Scalar factors of the elementary reflectors</TD></TR>
<TR><TD>ilo</TD><TD>Lowest index where the original matrix had been Hessenbergform - ilo must have the same value as in the previous call of DGEHRD</TD></TR>
<TR><TD>ihi</TD><TD>Highest index where the original matrix had been Hessenbergform  - ihi must have the same value as in the previous call of DGEHRD</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Q[size(A, 1), size(A, 2)]</TD><TD>Orthogonal matrix as a result of elementary reflectors</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE printMatrix<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.printMatrix"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.printMatrix</H2>
<B>Print matrix</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>M[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>significantDigits</TD><TD>Number of significant digits that are shown</TD></TR>
<TR><TD>name</TD><TD>Independent variable name used for printing</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>s</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE printMatrixInHtml<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.printMatrixInHtml"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.printMatrixInHtml</H2>
<B>Print a matrix in html format on file (without html/body heading)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>M[:, :]</TD><TD>Real matrix</TD></TR>
<TR><TD>name</TD><TD>Matrix name used for printing</TD></TR>
<TR><TD>fileName</TD><TD>Name of file to be printed in (incl. file extension)</TD></TR>
<TR><TD>format</TD><TD>Format of numbers (e.g. &quot;20.8e&quot;)</TD></TR>
<TR><TD>printIndices</TD><TD>=true, if row and column indices shall be printed, otherwise they are not printed</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE QR<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.QR"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.QR</H2>
<B>QR decomposition of a rectangular matrix without column pivoting (A = Q*R). Return the full square Q-matrix</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Rectangular matrix with size(A,1) &gt;= size(A,2)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Q[size(A, 1), size(A, 2)]</TD><TD>Rectangular matrix with orthonormal columns such that Q*R=A[:,p]</TD></TR>
<TR><TD>R[min(size(A, 1), size(A, 2)), size(A, 2)]</TD><TD>Square upper triangular matrix</TD></TR>
<TR><TD>tau[min(size(A, 1), size(A, 2))]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Q2[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE rcond<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Ma4ff825c368ce509rcondI.png" ALT="Modelica_LinearSystems2.Math.Matrices.rcond" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.rcond"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.rcond</H2>
<B>Reciprocal condition number</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
        r = Matrices.<b>rcond</b>(A);
(r, info) = Matrices.<b>rcond</b>(A, false);
</pre></blockquote>

<h4>Description</h4>
<p>
This function estimates the reciprocal of the condition number
(norm(<b>A</b>) * norm(inv(<b>A</b>))) of a general real matrix <b>A</b>,
in either the 1-norm or the infinity-norm, using the LAPACK function DGECON.
</p>

<h4>Example</h4>
<blockquote><pre>
  A = [1, 2
       2, 1];
  r = rcond(A);

  results in:

  r = 0.3333
</pre></blockquote>

<h4>See also</h4>
<p>
<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.conditionNumber"
>Matrices.conditionNumber</a>
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Square real matrix</TD></TR>
<TR><TD>inf</TD><TD>Is true if infinity norm is used and false for 1-norm</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>rcond</TD><TD>Reciprocal condition number of A</TD></TR>
<TR><TD>info</TD><TD>Information</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE rsf<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.rsf"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.rsf</H2>
<B>Computes the real Schur form (RSF) of a square matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
(T, Z, alphaReal, alphaImag) = Matrices.<b>rsf</b>(A)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>rsf</b> (real Schur form) calculates the real Schur form af
a real square matrix <b>A</b>, i.e.
</p>
<blockquote>
  <b>A</b> = <b>Z</b>*<b>T</b>*<b>Z</b><sup>T</sup>
</blockquote>
<p>
with the real nxn matrices <b>T</b> and <b>Z</b>. <b>Z</b> is an orthogonal matrix.
<b>T</b> is an block upper triangular matrix with 1x1 and 2x2 blocks in the diagonal.
The 1x1 blocks contains the real eigenvalues of&nbsp;a. The 2x2 blocks are matrices with
the conjugated complex pairs of eigenvalues, whereas the real parts of the eigenvalues
are the elements of the diagonal.
</p>
<p>
The calculation is performed stepwise using several lapack routines.
First, lapack.dgehrd reduces matrix <b>A</b> is to upper Hessenberg form
<b>H</b>=<b>Q'AQ</b>, whereas <b>Q</b> is computed by lapack.dodrghr.
Finally, lapack.dhseqr transforms <b>H</b> to <b>T</b>. The eigenvalues
of <b>A</b> are calculated straightforward from <b>T</b>.
</p>
<p>
Function <b>rsf</b> does not apply lapack.dgees, a routine to directly compute
the real Schur from.
</p>

<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1, 2, 3; 4, 5, 6; 7, 8, 9];
  Real T[3,3];
  Real Z[3,3];
  Real alphaReal[3];
  Real alphaImag[3];

<b>algorithm</b>
  (T, Z, alphaReal, alphaImag):=Modelica_LinearSystems2.Math.Matrices.rsf(A);
//   T = [16.12, 4.9,   1.59E-015;
//        0,    -1.12, -1.12E-015;
//        0,     0,    -1.30E-015]
//   Z = [-0.23,  -0.88,   0.41;
//        -0.52,  -0.24,  -0.82;
//        -0.82,   0.4,    0.41]
//alphaReal = {16.12, -1.12, -1.32E-015}
//alphaImag = {0, 0, 0}
</pre></blockquote>

<h4>See also</h4>
<p>
<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rsf2"
>Math.Matrices.rsf2</a>
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>T[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Z[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>alphaReal[size(A, 1)]</TD><TD>Real part of eigenvalue=alphaReal+i*alphaImag</TD></TR>
<TR><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of eigenvalue=(alphaReal+i*alphaImag</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE rsf2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.rsf2"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.rsf2</H2>
<B>Computes the real Schur form (RSF) of a square matrix but uses lapack.dgees</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
(T, Z, alphaReal, alphaImag) = Matrices.<b>rsf2</b>(A)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>rsf2</b> (real Schur form) calculates the real Schur form af
a real square matrix <b>A</b>, i.e.
</p>
<blockquote>
  <b>A</b> = <b>Z</b>*<b>T</b>*<b>Z</b><sup>T</sup>
</blockquote>
<p>
with the real nxn matrices <b>T</b> and <b>Z</b>. <b>Z</b> is an orthogonal matrix.
<b>T</b> is an block upper triangular matrix with 1x1 and 2x2 blocks in the diagonal.
The 1x1 blocks contains the real eigenvalues of&nbsp;a. The 2x2 blocks are matrices with
the conjugated complex pairs of eigenvalues, whereas the real parts of the eigenvalues
are the elements of the diagonal.
</p>
<p>
The calculation is performed stepwise using lapack.dgees, i.e. using the internal
mehtods of balacing and scaling of dgees.
</p>

<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1, 2, 3; 4, 5, 6; 7, 8, 9];
  Real T[3,3];
  Real Z[3,3];
  Real alphaReal[3];
  Real alphaImag[3];

<b>algorithm</b>
  (T, Z, alphaReal, alphaImag):=Modelica_LinearSystems2.Math.Matrices.rsf2(A);
//   T = [16.12, 4.9,   1.59E-015;
//        0,    -1.12, -1.12E-015;
//        0,     0,    -1.30E-015]
//   Z = [-0.23,  -0.88,   0.41;
//        -0.52,  -0.24,  -0.82;
//        -0.82,   0.4,    0.41]
//alphaReal = {16.12, -1.12, -1.32E-015}
//alphaImag = {0, 0, 0}
</pre></blockquote>

<h4>See also</h4>
<p>
<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rsf"
>Math.Matrices.rsf</a>
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>S[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>QZ[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>alphaReal[size(A, 1)]</TD><TD>Real part of eigenvalue=alphaReal+i*alphaImag</TD></TR>
<TR><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of eigenvalue=(alphaReal+i*alphaImag</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE solve<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Mb82816ef369aea08solveI.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.solve"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.solve</H2>
<B>Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>solve</b>(A,b);
</pre></blockquote>

<h4>Description</h4>
<p>
This function call returns the
solution <b>x</b> of the linear system of equations
</p>
<blockquote>
<b>A</b>*<b>x</b> = <b>b</b>
</blockquote>
<p>
If a unique solution <b>x</b> does not exist (since <b>A</b> is singular),
an exception is raised.
</p>

<h4>Note</h4>
<p>
The solution is computed with the LAPACK function "dgesv",
i.e., by Gaussian elemination with partial pivoting.
</p>

<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real b[3] = {10,22,12};
  Real x[3];
<b>algorithm</b>
  x := Matrices.solve(A,b);  // x = {3,2,1}
</pre></blockquote>

<h4>See also</h4>
<p>
Matrices.LU</a>,
Matrices.LU_solve</a>
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix A of A*x = b</TD></TR>
<TR><TD>b[size(A, 1)]</TD><TD>Vector b of A*x = b</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>x[size(b, 1)]</TD><TD>Vector x such that A*x = b</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE solve2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Mb82816ef369aea08solveI.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.solve2"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.solve2</H2>
<B>Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>solve2</b>(A,b);
</pre></blockquote>

<h4>Description</h4>
<p>
This function call returns the
solution <b>X</b> of the linear system of equations
</p>
<blockquote>
<p>
<b>A</b>*<b>X</b> = <b>B</b>
</p>
</blockquote>
<p>
If a unique solution <b>X</b> does not exist (since <b>A</b> is singular),
an exception is raised.
</p>

<h4>Note</h4>
<p>
The solution is computed with the LAPACK function "dgesv",
i.e., by Gaussian elemination with partial pivoting.
</p>

<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real B[3,2] = [10, 20;
                 22, 44;
                 12, 24];
  Real X[3,2];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  X := Matrices.solve2(A, B1);  /* X = [3, 6;
                                        2, 4;
                                        1, 2] */
</pre></blockquote>

<h4>See also</h4>
<p>
Matrices.LU</a>,
Matrices.LU_solve2</a>
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix A of A*X = B</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>Matrix B of A*X = B</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(B, 1), size(B, 2)]</TD><TD>Matrix X such that A*X = B</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE solve2r<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Mb82816ef369aea08solveI.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve2r" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.solve2r"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.solve2r</H2>
<B>Solve real system of linear equations X*op(A)=B with a B matrix (Gaussian elemination with partial pivoting)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
X = Matrices.<b>solve2r</b>(A,B);
X = Matrices.<b>solve2r</b>(A, B, transA=false, isTriangular=false);
</pre></blockquote>

<h4>Description</h4>
<p>
This function call returns the
solution <b>X</b> of the linear system of equations
</p>
<blockquote>
<p>
<b>X</b>*op<b>(A)</b> = <b>B</b>
</p>
</blockquote>
<p>
with
</p>
<blockquote>
<p>
op<b>(A)</b> = transpose(<b>(A)</b>)  if   transA==true
op<b>(A)</b> = <b>(A)</b>  if   transA==false
</p>
</blockquote>
<p>
If matrix <b>(A)</b> is already lower triangular, the factorization is avoided if input "isTriangular" is set true.
If a unique solution <b>X</b> does not exist (since <b>A</b> is singular),
an exception is raised.
</p>

<h4>Note</h4>
<p>
The solution is computed with the LAPACK function "dgesv",
i.e., by Gaussian elemination with partial pivoting.
</p>

<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];

  Real B[2,3]  = [10, 22, 12;
                  20, 44, 24];
  Real X[2,3];
<b>algorithm</b>
  X := Matrices.solve2r(A, B);  /* X = [-34.0, 17.2, 2.4;
                                        -68.0, 34.4, 4.8] */
</pre></blockquote>

<h4>See also</h4>
<p>
Matrices.LU</a>,
Matrices.LU_solve2</a>
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix A of X*op(A) = B</TD></TR>
<TR><TD>B[:, size(A, 1)]</TD><TD>Matrix B of X*op(A) = B</TD></TR>
<TR><TD>transA</TD><TD>True if op(A)=A&#39;, false if op(A)=A</TD></TR>
<TR><TD>isTriangular</TD><TD>True if the A is already lower triangular</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(B, 1), size(B, 2)]</TD><TD>Matrix X such that X*op(A) = B</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE sylvester<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.sylvester"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.sylvester</H2>
<B>Solution of continuous-time Sylvester equation A*X + X*B = C</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function computes the solution <b>X</b> of the continuous-time Sylvester equation
</p>
<blockquote><pre>
<b>A</b>*<b>X</b> + <b>X</b>*<b>B</b> = <b>C</b>
</pre></blockquote>
<p>
using the Schur method for Sylvester equations proposed by Bartels and Stewart [1].
</p>

<h4><a name="References">References</a></h4>
<dl>
<dt>&nbsp;[1] Bartels, R.H. and Stewart G.W. (1972):</dt>
<dd> <b>Algorithm 432: Solution of the matrix equation AX + XB = C</b>.
     Comm. ACM., Vol. 15, pp. 820-826.<br>&nbsp;</dd>
</dl>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix A</TD></TR>
<TR><TD>B[:, :]</TD><TD>Matrix B</TD></TR>
<TR><TD>C[size(A, 1), size(B, 2)]</TD><TD>Matrix C</TD></TR>
<TR><TD>aIsSchur</TD><TD>True if A has already real Schur form</TD></TR>
<TR><TD>bIsSchur</TD><TD>True if B has already real Schur form</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 1), size(B, 2)]</TD><TD>Solution of Sylvester equation</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE trace<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Mca19caf536e45ca8traceI.png" ALT="Modelica_LinearSystems2.Math.Matrices.trace" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.trace"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.trace</H2>
<B>Sum of the diagonal elements of A</B><p>
<P><H3>Information</H3></P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>result</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE triangle<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.triangle"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.triangle</H2>
<B>Return the upper/lower triangular part of a square matrix</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Square matrix</TD></TR>
<TR><TD>upper</TD><TD>True for upper triangle to return</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Tri[size(A, 1), size(A, 2)]</TD><TD>Triangular matrix</TD></TR>
</TABLE>
<address><a href="http://www.3ds.com/">Automatically generated</a> Fri Feb 08 00:21:54 2013.
</address></BODY>
</HTML>
